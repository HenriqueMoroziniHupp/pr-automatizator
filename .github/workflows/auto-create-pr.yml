name: Criar Pull Request Autom√°tico

# Define quando o workflow deve ser acionado
on:
  push:
    branches-ignore: # N√£o executa para pushes diretos na 'main' ou 'develop'
      - 'main'
      - 'develop' # Adicione outras branches principais se necess√°rio

jobs:
  create_pull_request:
    permissions: # Adicionar permiss√µes necess√°rias
      contents: write
      pull-requests: write

    runs-on: ubuntu-latest # Define o tipo de m√°quina para executar o job
    # Condi√ß√£o para n√£o executar se a branch for a 'main' (seguran√ßa extra)
    if: github.ref != 'refs/heads/main' && github.ref != 'refs/heads/develop'

    steps:
      # 1. Checkout do c√≥digo do reposit√≥rio
      - name: Checkout do c√≥digo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Isso permite buscar todo o hist√≥rico
          ref: ${{ github.ref }} # Refer√™ncia da branch atual

      # 2. Configurar Git para ter acesso a todas as branches
      - name: Configurar Git
        run: |
          git config --global user.name '${{ github.actor }}'
          git config --global user.email '${{ github.actor }}@users.noreply.github.com'
          git fetch origin main:main
          git fetch --all

      # 3. Obter o nome da branch atual
      - name: Obter nome da branch
        id: get_branch
        run: echo "BRANCH_NAME=$(echo ${GITHUB_REF#refs/heads/})" >> $GITHUB_OUTPUT

      # 4. Coletar commits
      - name: Coletar commits
        id: get_commits
        run: |
          git fetch origin main:main
          # Filtra commits de merge e pega apenas commits √∫nicos
          commits=$(git log origin/main..${{ steps.get_branch.outputs.BRANCH_NAME }} --no-merges --pretty="format:%s" --reverse)
          if [ -n "$commits" ]; then
            echo "COMMITS<<EOF" >> $GITHUB_OUTPUT
            echo "$commits" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            echo "COMMITS=" >> $GITHUB_OUTPUT
          fi

      # 4. Gerar o corpo (descri√ß√£o) do Pull Request
      # Este script bash itera sobre os commits, formata-os e monta a descri√ß√£o.
      - name: Gerar corpo do PR
        id: generate_pr_body
        shell: bash
        run: |
          IFS=$'\n' # Muda o separador de campos para nova linha
          commit_lines_formatted=""
          raw_commits="${{ steps.get_commits.outputs.COMMITS }}"

          if [ -z "$raw_commits" ]; then
            commit_lines_formatted="Nenhum commit novo para listar nesta branch em rela√ß√£o √† 'main'."
          else
            for commit_msg in $raw_commits; do
              # Tenta extrair 'tipo' e 'descri√ß√£o' do commit
              # Ex: "feat: Adiciona nova funcionalidade" -> tipo="feat", desc="Adiciona nova funcionalidade"
              if [[ "$commit_msg" == *":"* ]]; then
                commit_type=$(echo "$commit_msg" | cut -d':' -f1 | xargs) # xargs remove espa√ßos em branco extras
                commit_desc=$(echo "$commit_msg" | cut -d':' -f2- | sed 's/^[[:space:]]*//') # Remove espa√ßos no in√≠cio da descri√ß√£o
              else
                # Se n√£o seguir o padr√£o, classifica como 'misc'
                commit_type="misc"
                commit_desc="$commit_msg"
              fi

              # Mapeia o tipo do commit para um emoji correspondente
              emoji=""
              case "$commit_type" in
                feat)     emoji="‚ú®";;
                fix)      emoji="üêõ";;
                docs)     emoji="üìù";;
                style)    emoji="üíÖ";;
                refactor) emoji="‚ôªÔ∏è";;
                test)     emoji="‚úÖ";;
                perf)     emoji="üöÄ";;
                chore)    emoji="üîß";;
                ci)       emoji="‚öôÔ∏è";;
                *)        emoji="üìÑ";; # Emoji padr√£o para tipos n√£o listados ou 'misc'
              esac

              commit_lines_formatted="${commit_lines_formatted}- ${emoji} **${commit_type}:** ${commit_desc}\n"
            done
          fi

          # Remove a √∫ltima nova linha se houver commits formatados
          if [[ -n "$commit_lines_formatted" && "$commit_lines_formatted" == *'\n' ]]; then
              commit_lines_formatted=$(echo -e "${commit_lines_formatted%\\n}")
          fi
          
          # Monta o corpo do PR usando o template fornecido
          pr_body_content="T√≠tulo: Nova Release\n\nComent√°rio:\n#üìù Descri√ß√£o\n\n"
          pr_body_content="${pr_body_content}${commit_lines_formatted}"
          # Escapa caracteres especiais para sa√≠da em m√∫ltiplas linhas no GitHub Actions
          pr_body_content="${pr_body_content//'%'/'%25'}"
          pr_body_content="${pr_body_content//$'\n'/'%0A'}"
          pr_body_content="${pr_body_content//$'\r'/'%0D'}"
          
          echo "PR_BODY=$pr_body_content" >> $GITHUB_OUTPUT

      # 5. Criar Pull Request usando GitHub CLI
      - name: Instalar GitHub CLI
        run: |
          curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg \
          && sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg \
          && echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null \
          && sudo apt update \
          && sudo apt install gh -y

      - name: Criar Pull Request
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Debug: mostra informa√ß√µes sobre o token e a branch
          echo "Branch atual: ${{ steps.get_branch.outputs.BRANCH_NAME }}"
          
          # Tenta criar o PR e captura o resultado
          if ! gh pr view ${{ steps.get_branch.outputs.BRANCH_NAME }} &>/dev/null; then
            echo "Criando novo PR..."
            gh pr create \
              --title "PR Autom√°tico: ${{ steps.get_branch.outputs.BRANCH_NAME }} para main" \
              --body "${{ steps.generate_pr_body.outputs.PR_BODY }}" \
              --base main \
              --head ${{ steps.get_branch.outputs.BRANCH_NAME }} \
              --label "automacao" \
              --label "nova-release" || echo "Erro ao criar PR"
          else
            echo "PR j√° existe para esta branch"
          fi