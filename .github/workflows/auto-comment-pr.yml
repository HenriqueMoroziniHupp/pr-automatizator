# .github/workflows/auto-comment-pr.yml

# Nome do Workflow: Este nome aparecerÃ¡ na aba "Actions" do seu repositÃ³rio GitHub.
name: Auto Comment on New PR

# Gatilho (Trigger): Define quando este workflow serÃ¡ executado.
on:
  # Evento: pull_request
  pull_request:
    # Tipos: Especifica que o workflow deve rodar apenas quando uma PR for 'opened' (aberta).
    # Outros tipos comuns incluem 'reopened', 'synchronize' (quando novos commits sÃ£o adicionados), 'closed'.
    types: [opened, synchronize]

# Trabalhos (Jobs): Define uma ou mais tarefas que o workflow executarÃ¡.
jobs:
  # Nome do Job: Um nome descritivo para o trabalho.
  add-comment:
    # Runner: Especifica o tipo de mÃ¡quina virtual que executarÃ¡ o job.
    # 'ubuntu-latest' Ã© uma escolha comum e geralmente a mais atualizada.
    runs-on: ubuntu-latest

    # Passos (Steps): SequÃªncia de tarefas que compÃµem o job.
    steps:
      # Passo 1: Atualizar o corpo da Pull Request.
      - name: Update PR Body with Commit List
        # AÃ§Ã£o utilizada: actions/github-script@v7
        # Esta aÃ§Ã£o permite executar scripts que podem interagir com a API do GitHub.
        uses: actions/github-script@v7
        with:
          # Token do GitHub: NecessÃ¡rio para autenticar e autorizar a action a interagir com seu repositÃ³rio.
          github-token: ${{ secrets.GITHUB_TOKEN }}
          # Script: O cÃ³digo JavaScript que serÃ¡ executado.
          script: |
            const emojiMap = {
              'feat:': 'âœ¨',
              'fix:': 'ðŸ›',
              'docs:': 'ðŸ“',
              'style:': 'ðŸ’…',
              'refactor:': 'â™»ï¸',
              'test:': 'âœ…',
              'perf:': 'ðŸš€',
              'chore:': 'ðŸ”§',
              'ci:': 'âš™ï¸',
              'build:': 'ðŸ§±', // Adicionado
              'revert:': 'âª'  // Adicionado
            };

            const { data: commits } = await github.rest.pulls.listCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
            });

            let commitDetails = "Nenhum commit encontrado.";
            if (commits && commits.length > 0) {
              commitDetails = commits.map(commitData => {
                const fullMessage = commitData.commit.message.split('\n')[0]; // Pega apenas a primeira linha
                const commitUrl = commitData.html_url; // URL do commit
                let formattedMessage = ''; 
                let prefixMatched = false;

                for (const prefix in emojiMap) {
                  if (fullMessage.toLowerCase().startsWith(prefix)) {
                    const messageBody = fullMessage.substring(prefix.length).trim();
                    formattedMessage = `${emojiMap[prefix]} **${prefix}** [${messageBody}](${commitUrl})`;
                    prefixMatched = true;
                    break;
                  }
                }

                if (!prefixMatched) {
                  // Fallback para commits sem semÃ¢ntica conhecida
                  formattedMessage = `ðŸ“„ **misc:** [${fullMessage}](${commitUrl})`;
                }
                
                return formattedMessage;
              }).join('\n');
            }

            const descriptionSection = `
            ### DescriÃ§Ã£o

            ${commitDetails}
            `;

            const checklistContent = `

            ---

            #### ðŸ“Œ Lembretes:
            - [ ] Conferir branch de destino.
            - [ ] Adicionar labels (se aplicÃ¡vel).
            - [ ] A documentaÃ§Ã£o foi atualizada (se aplicÃ¡vel).
            `;

            const finalPrBody = descriptionSection + checklistContent;

            await github.rest.pulls.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
              body: finalPrBody
            });
            console.log(`Corpo da PR #${context.issue.number} atualizado com a lista de commits e checklist.`);