# .github/workflows/auto-comment-pr.yml

# Nome do Workflow: Este nome aparecer√° na aba "Actions" do seu reposit√≥rio GitHub.
name: Auto Comment on New PR

# Gatilho (Trigger): Define quando este workflow ser√° executado.
on:
  # Evento: pull_request
  pull_request:
    # Tipos: Especifica que o workflow deve rodar apenas quando uma PR for 'opened' (aberta).
    # Outros tipos comuns incluem 'reopened', 'synchronize' (quando novos commits s√£o adicionados), 'closed'.
    types: [opened]

# Trabalhos (Jobs): Define uma ou mais tarefas que o workflow executar√°.
jobs:
  # Nome do Job: Um nome descritivo para o trabalho.
  add-comment:
    # Runner: Especifica o tipo de m√°quina virtual que executar√° o job.
    # 'ubuntu-latest' √© uma escolha comum e geralmente a mais atualizada.
    runs-on: ubuntu-latest

    # Passos (Steps): Sequ√™ncia de tarefas que comp√µem o job.
    steps:
      # Passo 1: Atualizar o corpo da Pull Request.
      - name: Update PR Body with Commit List
        # A√ß√£o utilizada: actions/github-script@v7
        # Esta a√ß√£o permite executar scripts que podem interagir com a API do GitHub.
        uses: actions/github-script@v7
        with:
          # Token do GitHub: Necess√°rio para autenticar e autorizar a action a interagir com seu reposit√≥rio.
          github-token: ${{ secrets.GITHUB_TOKEN }}
          # Script: O c√≥digo JavaScript que ser√° executado.
          script: |
            const emojiMap = {
              'feat:': '‚ú®',
              'fix:': 'üêõ',
              'docs:': 'üìù',
              'style:': 'üíÖ',
              'refactor:': '‚ôªÔ∏è',
              'test:': '‚úÖ',
              'perf:': 'üöÄ',
              'chore:': 'üîß',
              'ci:': '‚öôÔ∏è',
              'build:': 'üß±', // Adicionado
              'revert:': '‚è™'  // Adicionado
            };

            const { data: commits } = await github.rest.pulls.listCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
            });

            let commitDetails = "Nenhum commit encontrado.";
            if (commits && commits.length > 0) {
              commitDetails = commits.map(commitData => {
                const fullMessage = commitData.commit.message.split('\n')[0]; // Pega apenas a primeira linha
                let formattedMessage = ''; 
                let prefixMatched = false;

                for (const prefix in emojiMap) {
                  if (fullMessage.toLowerCase().startsWith(prefix)) {
                    const messageBody = fullMessage.substring(prefix.length).trim();
                    formattedMessage = `${emojiMap[prefix]} **${prefix}** ${messageBody}`;
                    prefixMatched = true;
                    break;
                  }
                }

                if (!prefixMatched) {
                  // Fallback para commits sem sem√¢ntica conhecida
                  formattedMessage = `üìÑ **misc:** ${fullMessage}`;
                }
                
                return formattedMessage;
              }).join('\n');
            }

            const descriptionSection = `
            ### Descri√ß√£o

            ${commitDetails}
            `;

            const checklistContent = `

            ---

            **Lembretes:**
            - [ ] O c√≥digo segue os padr√µes de estilo do projeto.
            - [ ] Testes unit√°rios foram adicionados ou atualizados.
            - [ ] A documenta√ß√£o foi atualizada (se aplic√°vel).

            Nossa equipe ir√° revisar suas altera√ß√µes em breve.
            `;

            const finalPrBody = descriptionSection + checklistContent;

            await github.rest.pulls.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
              body: finalPrBody
            });
            console.log(`Corpo da PR #${context.issue.number} atualizado com a lista de commits e checklist.`);